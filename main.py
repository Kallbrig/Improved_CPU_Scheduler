from random import randint
from tabulate import tabulate

"""
    rr_scheduler is a simulated Round Robin Scheduler. The function performs a single round of scheduling and execution.

    :param rq -- It takes in a ready queue in the form of a list of dicts. These are generated in
                 the test_improved_vs_standard_rr function
    :param quantum -- The Time Quantum used in the round robin scheduler.

    :param wait -- Used for tracking total wait time only. Has no effect on operation.
"""


def rr_scheduler(rq, quantum, wait):
    ready_queue = rq
    removed = []

    for task in ready_queue:

        # if the task takes more than a quantum to complete
        if quantum <= task['time_until_completion']:

            # Increment the amount of time the CPU was actually working on the task
            task['total_burst_time'] = task['total_burst_time'] + quantum

            # subtract from how long the task requires to complete
            task['time_until_completion'] = task['time_until_completion'] - quantum

            # increments how long we have waited total.
            wait += quantum

            # Sets the most recent time spent on the CPU as a quantum
            task['most_recent_cycle_time'] = quantum

        # if the task takes less than a quantum to complete
        else:
            task['total_burst_time'] += task['time_until_completion']

            task['time_until_completion'] = 0

            wait += task['time_until_completion']

            task['most_recent_cycle_time'] = task['time_until_completion']

    for task in ready_queue:
        task['how_long_the_process_waits_total'] = task['how_long_the_process_waits_total'] + (
                wait - task['most_recent_cycle_time'])

        if task['time_until_completion'] == 0:
            removed.append(task)
            ready_queue.remove(task)

    new_queue = []

    for j in ready_queue:
        new_queue.append(j)

    return new_queue, removed, wait


"""
    print_removed_list prints a list of elements removed from the ready queue.
    This is only used by the standard_rr and improved_rr functions when print_bool is true.

    :param rem_list -- A list of elements that have been removed from the ready queue.
                   This is meant to take in a full ready queue of already executed tasks.
                   **If a non-executed ready_queue is passed, the values printed will not be correct.**

    *TO-DO*
    Should be replaced with a tabulate function in the future.
    When Implemented the tabulate function can be located here
    or in the standard_rr and improved_rr functions.

"""


def print_removed_list(rem_list):
    print('Process Name - CPU Time  - Waiting Time - Total Execution Time')

    for task in rem_list:
        print(
            f"    P{task['process']}{' ' * 12}{task['total_cpu_time_needed']}{' ' * 12}{task['how_long_the_process_waits_total']}{' ' * 13}{task['how_long_the_process_waits_total'] + task['total_cpu_time_needed']}")
        # print(f"    ")


"""
    calc_averages is a function used to generate the averages of a ready queue's cpu_time, wait_time, and total_time

    :param rem_list -- A list of elements that have been removed from the ready queue.
                       This is meant to take in a full ready queue of already executed tasks.
                       **If a non-executed ready_queue is passed, the values returned will not be correct.**
"""


def calc_averages(rem_list):
    cpu_time = 0
    how_long_the_process_waits_total = 0
    total_time = 0

    for i in rem_list:
        cpu_time += i['total_burst_time']
        how_long_the_process_waits_total += i['how_long_the_process_waits_total']
        total_time += i['how_long_the_process_waits_total'] + i['total_cpu_time_needed']

    cpu_time = cpu_time / len(rem_list)
    how_long_the_process_waits_total = how_long_the_process_waits_total / len(rem_list)
    total_time = total_time / len(rem_list)
    return round(cpu_time, 1), round(how_long_the_process_waits_total, 1), round(total_time, 1)


"""
    Standard RR is an implementation of a standard round robin scheduler with a fixed quantum (2)

    :param ready_queue -- a ready queue. In the current implementation this is generated by 
                          the test_improved_vs_standard_rr function. 
    :param print_bool -- a boolean value signifying rather the ready queue should be printed to the terminal


"""


def standard_rr(ready_queue: list[dict], print_bool: bool):
    wait = 0
    removed_list = []

    # DRIVER LOOP
    while ready_queue:
        ready_queue, removed, wait = rr_scheduler(ready_queue, 2, wait)
        if removed:
            for i in removed:
                removed_list.append(i)

    cpu_time, how_long_the_process_waits_total, total_time = calc_averages(removed_list)

    if print_bool == True:
        print('Standard')

        print_removed_list(removed_list)

        print(
            f"Averages{' ' * 9}{cpu_time.__round__(1)}{' ' * 11}{how_long_the_process_waits_total.__round__(1)}{' ' * 9}{total_time.__round__(1)}")
    return [cpu_time, how_long_the_process_waits_total, total_time]


"""
    Improved RR is an implementation of *An Improved Round Robin CPU Scheduling Algorithm with 
    Varying Time Quantum* (IRRVQ) presented by Manish Kumar Mishra and Dr. Fazur Rashid in their
    paper by the same name from 2014.

    :param ready_queue -- a ready queue. In the current implementation this is generated by 
                          the test_improved_vs_standard_rr function. 
    :param print_bool -- a boolean value signifying rather the ready queue should be printed to the terminal


"""


def improved_rr(ready_queue: list[dict], print_bool: bool):
    wait = 0
    removed_list = []

    # DRIVER LOOP
    while ready_queue:
        ready_queue = sorted(ready_queue, key=lambda i: i['time_until_completion'])
        quantum = ready_queue[0]['time_until_completion']
        # print(quantum)
        ready_queue, removed, wait = rr_scheduler(ready_queue, quantum, wait)
        if removed:
            for i in removed:
                removed_list.append(i)

    cpu_time, how_long_the_process_waits_total, total_time = calc_averages(removed_list)

    if print_bool == True:
        print('Standard')

        print_removed_list(removed_list)

        print(
            f"Averages{' ' * 9}{cpu_time.__round__(1)}{' ' * 11}{how_long_the_process_waits_total.__round__(1)}{' ' * 9}{total_time.__round__(1)}")
        print()

    return [cpu_time, how_long_the_process_waits_total, total_time]


"""
    test_improved_vs_standard_rr generates ready queues in the form of dictionaries
    and puts them through the standard Round Robin scheduler as well as the
    improved Round Robin Scheduler. This is the driver function of the script.

    :param len_ready_queue -- The length of the ready queue to test
                              It looks like the longer the ready queue the worse the improved RR performs

"""


def test_improved_vs_standard_rr(len_ready_queue: int):
    imp_ready = []
    std_ready = []
    for i in range(1, len_ready_queue):
        r = randint(1, 50)

        std_ready.append({'process': int(i),
                          'how_long_the_process_waits_total': 0,
                          'total_cpu_time_needed': r,
                          'time_until_completion': r,
                          'total_burst_time': 0,
                          'most_recent_cycle_time': 0})
        imp_ready.append({'process': int(i),
                          'how_long_the_process_waits_total': 0,
                          'total_cpu_time_needed': r,
                          'time_until_completion': r,
                          'total_burst_time': 0,
                          'most_recent_cycle_time': 0})

    standard_stats = standard_rr(std_ready, False)
    standard_stats.insert(0, 'Standard RR')
    standard_stats.insert(1, len_ready_queue)
    imp_stats = improved_rr(imp_ready, False)
    imp_stats.insert(0, 'Improved RR')
    imp_stats.insert(1, len_ready_queue)
    print(
        tabulate([standard_stats, imp_stats],
                 headers=['Averages', 'Number of Tasks', 'CPU Time Needed', 'Waiting Time', 'Total Time'],
                 tablefmt='orgtbl'))
    print()


if __name__ == "__main__":
    print('\n****  Round Robin Scheduler  ****')
    print('Standard Round Robin vs. Improved Round Robin CPU Scheduling Algorithm With Varying Time Quantum (IRRVQ)\n')
    len_rq = int(input('Please input the length of the ready queue.\n'))
    print()
    test_improved_vs_standard_rr(len_rq)
